"""Configuration for network generation.

This module defines attribute weights for similarity calculations,
degree correction multipliers, edge type rules, and influence factors.

NetworkConfig can be generated by LLM from a population spec or
loaded from YAML for manual customization.
"""

from pathlib import Path
from typing import Any, Literal

import yaml
from pydantic import BaseModel, Field


class AttributeWeightConfig(BaseModel):
    """Configuration for how an attribute contributes to similarity.

    Attributes:
        weight: Base weight for this attribute (higher = more important)
        match_type: How to compute match score:
            - "exact": 1 if exact match, 0 otherwise
            - "numeric_range": 1 - |A - B| / range (normalized difference)
            - "within_n": 1 if within n levels, 0 otherwise
        range_value: For numeric_range, the normalization range; for within_n, the allowed difference
        ordinal_levels: For within_n match type, maps option values to ordinal integers.
            If None, falls back to config-level ordinal_levels for backward compat.
    """

    weight: float
    match_type: str = "exact"
    range_value: float | None = None
    ordinal_levels: dict[str, int] | None = None


class DegreeMultiplierConfig(BaseModel):
    """Configuration for degree correction multipliers.

    Certain agents are more connected based on their attributes.
    Multipliers stack multiplicatively.
    """

    attribute: str
    condition: Any  # Value to match (or callable for complex conditions)
    multiplier: float
    rationale: str


class EdgeTypeRule(BaseModel):
    """Rule for inferring edge types between connected agents.

    Rules are evaluated in priority order (highest first).
    The condition is a simple expression referencing agent attributes
    with `a_` and `b_` prefixes (e.g., "a_employer == b_employer").

    Attributes:
        name: Edge type label (e.g., "colleague", "neighbor")
        condition: Expression evaluated against agent pair attributes.
            Available variables: a_{attr} and b_{attr} for each agent attribute.
            Supports ==, !=, and, or, not, in.
        priority: Higher priority rules are checked first. Default 0.
        description: Human-readable explanation of when this edge type applies.
    """

    name: str
    condition: str
    priority: int = 0
    description: str = ""


class InfluenceFactorConfig(BaseModel):
    """Configuration for how an attribute affects influence weight between agents.

    Used by _compute_influence_weights() to determine asymmetric influence
    (e.g., senior people influence junior people more).

    Attributes:
        attribute: Agent attribute name to evaluate.
        type: How to interpret the attribute:
            - "ordinal": Uses levels mapping to compute ratio (higher influences lower)
            - "boolean": Presence/absence adds weight bonus
            - "numeric": Raw numeric ratio (dampened)
        levels: For ordinal type, maps attribute values to numeric rank.
            Higher rank = more influence.
        weight: How much this factor contributes. Default 0.2.
        description: Human-readable explanation.
    """

    attribute: str
    type: Literal["ordinal", "boolean", "numeric"]
    levels: dict[str, int] | None = None
    weight: float = 0.2
    description: str = ""


class NetworkConfig(BaseModel):
    """Complete configuration for network generation.

    Can be generated by LLM from a population spec, loaded from YAML,
    or constructed manually. Empty defaults produce a flat network;
    use GERMAN_SURGEON_CONFIG for the original hardcoded behavior.

    Attributes:
        avg_degree: Target average degree (connections per agent)
        rewire_prob: Watts-Strogatz rewiring probability
        similarity_threshold: Sigmoid threshold for edge probability
        similarity_steepness: Sigmoid steepness for edge probability
        attribute_weights: Weights for similarity calculation
        degree_multipliers: Multipliers for degree correction
        edge_type_rules: Rules for inferring edge types (evaluated by priority)
        influence_factors: Factors for computing asymmetric influence weights
        default_edge_type: Fallback edge type when no rule matches
        ordinal_levels: Global ordinal level mappings (keyed by attribute name).
            Used by within_n match type when AttributeWeightConfig.ordinal_levels is None.
        generated_from: Description of what population this config was generated for
        generation_rationale: LLM's reasoning for the chosen configuration
        seed: Random seed for reproducibility
    """

    avg_degree: float = 20.0
    rewire_prob: float = 0.05
    similarity_threshold: float = 0.3
    similarity_steepness: float = 10.0
    attribute_weights: dict[str, AttributeWeightConfig] = Field(default_factory=dict)
    degree_multipliers: list[DegreeMultiplierConfig] = Field(default_factory=list)
    edge_type_rules: list[EdgeTypeRule] = Field(default_factory=list)
    influence_factors: list[InfluenceFactorConfig] = Field(default_factory=list)
    default_edge_type: str = "peer"
    ordinal_levels: dict[str, dict[str, int]] = Field(default_factory=dict)
    generated_from: str | None = None
    generation_rationale: str | None = None
    seed: int | None = None

    def get_total_weight(self) -> float:
        """Get total weight for normalization."""
        return sum(cfg.weight for cfg in self.attribute_weights.values())

    def get_ordinal_levels(self, attribute: str) -> dict[str, int] | None:
        """Get ordinal levels for an attribute.

        Checks attribute-level config first, then falls back to
        config-level ordinal_levels.
        """
        attr_config = self.attribute_weights.get(attribute)
        if attr_config and attr_config.ordinal_levels is not None:
            return attr_config.ordinal_levels
        return self.ordinal_levels.get(attribute)

    def to_yaml(self, path: str | Path) -> None:
        """Save config to a YAML file."""
        path = Path(path)
        data = self.model_dump(exclude_none=True, exclude_defaults=False)
        # Clean up empty collections for readability
        for key in list(data.keys()):
            if isinstance(data[key], (list, dict)) and not data[key]:
                del data[key]
        path.parent.mkdir(parents=True, exist_ok=True)
        with open(path, "w") as f:
            yaml.dump(data, f, default_flow_style=False, sort_keys=False)

    @classmethod
    def from_yaml(cls, path: str | Path) -> "NetworkConfig":
        """Load config from a YAML file."""
        path = Path(path)
        with open(path) as f:
            data = yaml.safe_load(f) or {}
        return cls.model_validate(data)


# ============================================================================
# German Surgeon Reference Config
# ============================================================================
# Preserves the original hardcoded defaults for backward compatibility
# and as a reference example of a fully configured network.

_GERMAN_SURGEON_ATTRIBUTE_WEIGHTS: dict[str, AttributeWeightConfig] = {
    # Same hospital = daily interaction
    "employer_type": AttributeWeightConfig(weight=3.0, match_type="exact"),
    # Specialty societies, conferences, shared cases
    "surgical_specialty": AttributeWeightConfig(weight=2.5, match_type="exact"),
    # Geographic proximity, regional networks
    "federal_state": AttributeWeightConfig(weight=2.0, match_type="exact"),
    # Chiefs know senior physicians, not residents
    "role_seniority": AttributeWeightConfig(
        weight=1.5, match_type="within_n", range_value=1
    ),
    # Tertiary centers form networks
    "care_level": AttributeWeightConfig(weight=1.0, match_type="exact"),
    # Generational cohorts, training cohorts
    "age": AttributeWeightConfig(
        weight=1.0, match_type="numeric_range", range_value=10
    ),
    # Academic networks
    "participation_in_research": AttributeWeightConfig(weight=0.5, match_type="exact"),
    # Society meetings, committees
    "professional_society_membership": AttributeWeightConfig(
        weight=0.5, match_type="exact"
    ),
}

_GERMAN_SURGEON_SENIORITY_LEVELS: dict[str, int] = {
    "resident": 1,
    "specialist_attending": 2,
    "senior_physician_Oberarzt": 3,
    "chief_physician_Chefarzt": 4,
}

_GERMAN_SURGEON_DEGREE_MULTIPLIERS: list[DegreeMultiplierConfig] = [
    DegreeMultiplierConfig(
        attribute="role_seniority",
        condition="chief_physician_Chefarzt",
        multiplier=2.0,
        rationale="Department heads know everyone",
    ),
    DegreeMultiplierConfig(
        attribute="role_seniority",
        condition="senior_physician_Oberarzt",
        multiplier=1.3,
        rationale="Mid-level leadership",
    ),
    DegreeMultiplierConfig(
        attribute="teaching_responsibility",
        condition=True,
        multiplier=1.4,
        rationale="Mentors many residents",
    ),
    DegreeMultiplierConfig(
        attribute="participation_in_research",
        condition=True,
        multiplier=1.3,
        rationale="Collaborations, publications",
    ),
    DegreeMultiplierConfig(
        attribute="professional_society_membership",
        condition=True,
        multiplier=1.2,
        rationale="Committee work, conferences",
    ),
    DegreeMultiplierConfig(
        attribute="employer_type",
        condition="university_hospital",
        multiplier=1.2,
        rationale="Larger institutions, more colleagues",
    ),
]

_GERMAN_SURGEON_EDGE_TYPE_RULES: list[EdgeTypeRule] = [
    EdgeTypeRule(
        name="mentor_mentee",
        condition="a_employer_type == b_employer_type and a_role_seniority != b_role_seniority",
        priority=50,
        description="Same hospital, different seniority — training relationship",
    ),
    EdgeTypeRule(
        name="colleague",
        condition="a_employer_type == b_employer_type",
        priority=40,
        description="Same hospital — daily coworkers",
    ),
    EdgeTypeRule(
        name="specialty_peer",
        condition="a_surgical_specialty == b_surgical_specialty",
        priority=30,
        description="Same specialty — conferences, society meetings",
    ),
    EdgeTypeRule(
        name="regional",
        condition="a_federal_state == b_federal_state",
        priority=20,
        description="Same state — regional referral network",
    ),
]

_GERMAN_SURGEON_INFLUENCE_FACTORS: list[InfluenceFactorConfig] = [
    InfluenceFactorConfig(
        attribute="role_seniority",
        type="ordinal",
        levels=_GERMAN_SURGEON_SENIORITY_LEVELS,
        weight=0.3,
        description="Senior surgeons influence junior ones more",
    ),
    InfluenceFactorConfig(
        attribute="participation_in_research",
        type="boolean",
        weight=0.2,
        description="Researchers carry academic credibility",
    ),
    InfluenceFactorConfig(
        attribute="teaching_responsibility",
        type="boolean",
        weight=0.1,
        description="Teachers influence through mentorship",
    ),
]

GERMAN_SURGEON_CONFIG = NetworkConfig(
    avg_degree=20.0,
    rewire_prob=0.05,
    similarity_threshold=0.3,
    similarity_steepness=10.0,
    attribute_weights=_GERMAN_SURGEON_ATTRIBUTE_WEIGHTS,
    degree_multipliers=_GERMAN_SURGEON_DEGREE_MULTIPLIERS,
    edge_type_rules=_GERMAN_SURGEON_EDGE_TYPE_RULES,
    influence_factors=_GERMAN_SURGEON_INFLUENCE_FACTORS,
    default_edge_type="weak_tie",
    ordinal_levels={"role_seniority": _GERMAN_SURGEON_SENIORITY_LEVELS},
    generated_from="German surgical profession population (reference config)",
)
